/*
 * ADC.c
 *
 *  Created on: 2023��8��22��
 *      Author: MiniSforum
 */
#include "ADC.h"
extern Uint32 samplingValue[4];
static Uchar8 samplingOkFlag = 0;
#define MAX_SAMPLING_CHANNEL 4
#define SAMPLING_COUNT 100
#define CAL_EXPANSION_FACTOR 1000
#define STANDARD_INPUT 1600
#define STANDARD_OUTPUT 800
typedef struct
{
    Uint16 outputVolAdjust;
    Uint16 inputVolAdjust;
    Uint16 tempVolAdjust;
    Uint16 currentAdjust;
} CalAdjust;
static CalAdjust calAdjust;
void ADCInit(void)
{
    // 1.config ADC
    InitAdc();
    EALLOW;
    AdcRegs.ADCTRL1.bit.ACQ_PS = 0xf;
    AdcRegs.ADCTRL3.bit.ADCCLKPS = 0x1;                          // 25/1 = 25MHZ
    AdcRegs.ADCTRL1.bit.SEQ_CASC = 1;                            // cascade mode
    AdcRegs.ADCCHSELSEQ1.bit.CONV00 = 0x8;                       // B0 sampling channel
    AdcRegs.ADCCHSELSEQ1.bit.CONV01 = 0xA;                       // B2
    AdcRegs.ADCCHSELSEQ1.bit.CONV02 = 0xC;                       // B4
    AdcRegs.ADCCHSELSEQ1.bit.CONV03 = 0xE;                       // B6
    AdcRegs.ADCTRL1.bit.CONT_RUN = 1;                            // continuous run
    AdcRegs.ADCMAXCONV.bit.MAX_CONV1 = MAX_SAMPLING_CHANNEL - 1; // max sampling channel
    // start SEQ1
    AdcRegs.ADCTRL2.all = 0x2000;
    EDIS;

    calAdjust.outputVolAdjust = 0;
    calAdjust.inputVolAdjust = 0;
    calAdjust.tempVolAdjust = 0;
    calAdjust.currentAdjust = 0;
}
Uint16 ADCReadValue(void)
{
    static Uint16 calCount = 0;
    if ((++calCount > SAMPLING_COUNT) && (samplingOkFlag != 1))
    {
        elecCalData.outputVol = samplingValue[3] / SAMPLING_COUNT;
        elecCalData.inputVol = samplingValue[2] / SAMPLING_COUNT;
        elecCalData.tempVol = samplingValue[1] / SAMPLING_COUNT;
        elecCalData.current = samplingValue[0] / SAMPLING_COUNT;
        for (calCount = 0; calCount < MAX_SAMPLING_CHANNEL; calCount++)
            samplingValue[calCount] = 0;
        calCount = 0;
        samplingOkFlag = 1;
    }
    while (AdcRegs.ADCST.bit.INT_SEQ1 != 1)
        ;
    samplingValue[0] += AdcRegs.ADCRESULT0 >> 4;
    samplingValue[1] += AdcRegs.ADCRESULT1 >> 4;
    samplingValue[2] += AdcRegs.ADCRESULT2 >> 4;
    samplingValue[3] += AdcRegs.ADCRESULT3 >> 4;
    AdcRegs.ADCST.bit.INT_SEQ1_CLR = 1; // clear flag bit

    return 1;
}

Uint16 ADCConvertCalData(void)
{
    if (samplingOkFlag)
    {
        int16 error;
        error = elecData.outputVol - useData.outputVol * 100;
        if (error > 5 || error < -5)
        {
            calAdjust.outputVolAdjust++;
        }else if(error >10 || error < -20){
            calAdjust.outputVolAdjust--;
        }
        elecData.outputVol = ((elecCalData.outputVol + calAdjust.outputVolAdjust) * 3 * CAL_EXPANSION_FACTOR) / 4096;
        elecData.inputVol = ((elecCalData.inputVol + calAdjust.inputVolAdjust) * 3 * CAL_EXPANSION_FACTOR) / 4096;
        elecData.tempVol = ((elecCalData.tempVol + calAdjust.tempVolAdjust) * 3 * CAL_EXPANSION_FACTOR) / 4096;
        elecData.current = ((elecCalData.current + calAdjust.currentAdjust) * 3 * CAL_EXPANSION_FACTOR) / 4096;
        samplingOkFlag = 0;
        return 1;
    }
    return 0;
}

// Uint16 ADCCalAdjustSeftTest()
// {

//     elecData.outputVol = ((elecCalData.outputVol + calAdjust.outputVolAdjust) * 3 * CAL_EXPANSION_FACTOR) / 4096;
//     elecData.inputVol = ((elecCalData.inputVol + calAdjust.inputVolAdjust) * 3 * CAL_EXPANSION_FACTOR) / 4096;
//     elecData.tempVol = ((elecCalData.tempVol + calAdjust.tempVolAdjust) * 3 * CAL_EXPANSION_FACTOR) / 4096;
//     elecData.current = ((elecCalData.current + calAdjust.currentAdjust) * 3 * CAL_EXPANSION_FACTOR) / 4096;

//     error = elecCalData.inputVol - STANDARD_INPUT;
//     if (error > 10 || error < 10)
//     {
//         calAdjust.inputVolAdjust++;
//     }
// }
